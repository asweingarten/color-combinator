<head><style type="text/css">h1.svelte-1ucbz36{color:purple}
html, body {
	position: relative;
	width: 100%;
	height: 100%;
}

body {
	color: #333;
	margin: 0;
	padding: 8px;
	box-sizing: border-box;
	font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
}

a {
	color: rgb(0,100,200);
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:visited {
	color: rgb(0,80,160);
}

label {
	display: block;
}

input, button, select, textarea {
	font-family: inherit;
	font-size: inherit;
	padding: 0.4em;
	margin: 0 0 0.5em 0;
	box-sizing: border-box;
	border: 1px solid #ccc;
	border-radius: 2px;
}

input:disabled {
	color: #ccc;
}

input[type="range"] {
	height: 0;
}

button {
	background-color: #f4f4f4;
	outline: none;
}

button:active {
	background-color: #ddd;
}

button:focus {
	border-color: #666;
}

/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wdWJsaWMvYnVuZGxlLmNzcyIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvZ2xvYmFsLmNzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxrQkFBa0IsYTtBQ0FsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQyIsImZpbGUiOiJzdHlsZS5jc3MiLCJzb3VyY2VzQ29udGVudCI6WyJoMS5zdmVsdGUtMXVjYnozNntjb2xvcjpwdXJwbGV9IiwiaHRtbCwgYm9keSB7XG5cdHBvc2l0aW9uOiByZWxhdGl2ZTtcblx0d2lkdGg6IDEwMCU7XG5cdGhlaWdodDogMTAwJTtcbn1cblxuYm9keSB7XG5cdGNvbG9yOiAjMzMzO1xuXHRtYXJnaW46IDA7XG5cdHBhZGRpbmc6IDhweDtcblx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0Zm9udC1mYW1pbHk6IC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgXCJTZWdvZSBVSVwiLCBSb2JvdG8sIE94eWdlbi1TYW5zLCBVYnVudHUsIENhbnRhcmVsbCwgXCJIZWx2ZXRpY2EgTmV1ZVwiLCBzYW5zLXNlcmlmO1xufVxuXG5hIHtcblx0Y29sb3I6IHJnYigwLDEwMCwyMDApO1xuXHR0ZXh0LWRlY29yYXRpb246IG5vbmU7XG59XG5cbmE6aG92ZXIge1xuXHR0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcbn1cblxuYTp2aXNpdGVkIHtcblx0Y29sb3I6IHJnYigwLDgwLDE2MCk7XG59XG5cbmxhYmVsIHtcblx0ZGlzcGxheTogYmxvY2s7XG59XG5cbmlucHV0LCBidXR0b24sIHNlbGVjdCwgdGV4dGFyZWEge1xuXHRmb250LWZhbWlseTogaW5oZXJpdDtcblx0Zm9udC1zaXplOiBpbmhlcml0O1xuXHRwYWRkaW5nOiAwLjRlbTtcblx0bWFyZ2luOiAwIDAgMC41ZW0gMDtcblx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0Ym9yZGVyOiAxcHggc29saWQgI2NjYztcblx0Ym9yZGVyLXJhZGl1czogMnB4O1xufVxuXG5pbnB1dDpkaXNhYmxlZCB7XG5cdGNvbG9yOiAjY2NjO1xufVxuXG5pbnB1dFt0eXBlPVwicmFuZ2VcIl0ge1xuXHRoZWlnaHQ6IDA7XG59XG5cbmJ1dHRvbiB7XG5cdGJhY2tncm91bmQtY29sb3I6ICNmNGY0ZjQ7XG5cdG91dGxpbmU6IG5vbmU7XG59XG5cbmJ1dHRvbjphY3RpdmUge1xuXHRiYWNrZ3JvdW5kLWNvbG9yOiAjZGRkO1xufVxuXG5idXR0b246Zm9jdXMge1xuXHRib3JkZXItY29sb3I6ICM2NjY7XG59Il0sInNvdXJjZVJvb3QiOiIifQ==*/</style></head><div id="plugin"></div>

<script type="text/javascript">/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./public/bundle.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./public/bundle.js":
/*!**************************!*\
  !*** ./public/bundle.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

var app = (function () {
    'use strict';

    function noop() { }
    function assign(tar, src) {
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    function validate_store(store, name) {
        if (!store || typeof store.subscribe !== 'function') {
            throw new Error(`'${name}' is not a store with a 'subscribe' method`);
        }
    }
    function subscribe(component, store, callback) {
        const unsub = store.subscribe(callback);
        component.$$.on_destroy.push(unsub.unsubscribe
            ? () => unsub.unsubscribe()
            : unsub);
    }
    function create_slot(definition, ctx, fn) {
        if (definition) {
            const slot_ctx = get_slot_context(definition, ctx, fn);
            return definition[0](slot_ctx);
        }
    }
    function get_slot_context(definition, ctx, fn) {
        return definition[1]
            ? assign({}, assign(ctx.$$scope.ctx, definition[1](fn ? fn(ctx) : {})))
            : ctx.$$scope.ctx;
    }
    function get_slot_changes(definition, ctx, changed, fn) {
        return definition[1]
            ? assign({}, assign(ctx.$$scope.changed || {}, definition[1](fn ? fn(changed) : {})))
            : ctx.$$scope.changed || {};
    }

    function append(target, node) {
        target.appendChild(node);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function element(name) {
        return document.createElement(name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_data(text, data) {
        data = '' + data;
        if (text.data !== data)
            text.data = data;
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error(`Function called outside component initialization`);
        return current_component;
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }

    const dirty_components = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    function flush() {
        const seen_callbacks = new Set();
        do {
            // first, call beforeUpdate functions
            // and update components
            while (dirty_components.length) {
                const component = dirty_components.shift();
                set_current_component(component);
                update(component.$$);
            }
            while (binding_callbacks.length)
                binding_callbacks.shift()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            while (render_callbacks.length) {
                const callback = render_callbacks.pop();
                if (!seen_callbacks.has(callback)) {
                    callback();
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                }
            }
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
    }
    function update($$) {
        if ($$.fragment) {
            $$.update($$.dirty);
            run_all($$.before_render);
            $$.fragment.p($$.dirty, $$.ctx);
            $$.dirty = null;
            $$.after_render.forEach(add_render_callback);
        }
    }
    function mount_component(component, target, anchor) {
        const { fragment, on_mount, on_destroy, after_render } = component.$$;
        fragment.m(target, anchor);
        // onMount happens after the initial afterUpdate. Because
        // afterUpdate callbacks happen in reverse order (inner first)
        // we schedule onMount callbacks before afterUpdate callbacks
        add_render_callback(() => {
            const new_on_destroy = on_mount.map(run).filter(is_function);
            if (on_destroy) {
                on_destroy.push(...new_on_destroy);
            }
            else {
                // Edge case - component was destroyed immediately,
                // most likely as a result of a binding initialising
                run_all(new_on_destroy);
            }
            component.$$.on_mount = [];
        });
        after_render.forEach(add_render_callback);
    }
    function destroy(component, detaching) {
        if (component.$$) {
            run_all(component.$$.on_destroy);
            component.$$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            component.$$.on_destroy = component.$$.fragment = null;
            component.$$.ctx = {};
        }
    }
    function make_dirty(component, key) {
        if (!component.$$.dirty) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty = blank_object();
        }
        component.$$.dirty[key] = true;
    }
    function init(component, options, instance, create_fragment, not_equal$$1, prop_names) {
        const parent_component = current_component;
        set_current_component(component);
        const props = options.props || {};
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props: prop_names,
            update: noop,
            not_equal: not_equal$$1,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            before_render: [],
            after_render: [],
            context: new Map(parent_component ? parent_component.$$.context : []),
            // everything else
            callbacks: blank_object(),
            dirty: null
        };
        let ready = false;
        $$.ctx = instance
            ? instance(component, props, (key, value) => {
                if ($$.ctx && not_equal$$1($$.ctx[key], $$.ctx[key] = value)) {
                    if ($$.bound[key])
                        $$.bound[key](value);
                    if (ready)
                        make_dirty(component, key);
                }
            })
            : props;
        $$.update();
        ready = true;
        run_all($$.before_render);
        $$.fragment = create_fragment($$.ctx);
        if (options.target) {
            if (options.hydrate) {
                $$.fragment.l(children(options.target));
            }
            else {
                $$.fragment.c();
            }
            if (options.intro && component.$$.fragment.i)
                component.$$.fragment.i();
            mount_component(component, options.target, options.anchor);
            flush();
        }
        set_current_component(parent_component);
    }
    class SvelteComponent {
        $destroy() {
            destroy(this, true);
            this.$destroy = noop;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set() {
            // overridden by instance, if it has props
        }
    }
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error(`'target' is a required option`);
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn(`Component was already destroyed`); // eslint-disable-line no-console
            };
        }
    }

    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop) {
        let stop;
        const subscribers = [];
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (!stop) {
                    return; // not ready
                }
                subscribers.forEach((s) => s[1]());
                subscribers.forEach((s) => s[0](value));
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop) {
            const subscriber = [run, invalidate];
            subscribers.push(subscriber);
            if (subscribers.length === 1) {
                stop = start(set) || noop;
            }
            run(value);
            return () => {
                const index = subscribers.indexOf(subscriber);
                if (index !== -1) {
                    subscribers.splice(index, 1);
                }
                if (subscribers.length === 0) {
                    stop();
                }
            };
        }
        return { set, update, subscribe };
    }

    /* src/Counter.svelte generated by Svelte v3.4.4 */

    const file = "src/Counter.svelte";

    function create_fragment(ctx) {
    	var div1, t0, t1, div0, t2, t3, button0, t5, button1, current, dispose;

    	const default_slot_1 = ctx.$$slots.default;
    	const default_slot = create_slot(default_slot_1, ctx, null);

    	return {
    		c: function create() {
    			div1 = element("div");

    			if (!default_slot) {
    				t0 = text("Default Counter");
    			}

    			if (default_slot) default_slot.c();
    			t1 = space();
    			div0 = element("div");
    			t2 = text(ctx.value);
    			t3 = space();
    			button0 = element("button");
    			button0.textContent = "+";
    			t5 = space();
    			button1 = element("button");
    			button1.textContent = "-";

    			add_location(button0, file, 4, 4, 61);
    			add_location(button1, file, 5, 4, 117);
    			add_location(div0, file, 2, 2, 39);
    			add_location(div1, file, 0, 0, 0);

    			dispose = [
    				listen(button0, "click", ctx.click_handler),
    				listen(button1, "click", ctx.click_handler_1)
    			];
    		},

    		l: function claim(nodes) {
    			if (default_slot) default_slot.l(div1_nodes);
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, div1, anchor);

    			if (!default_slot) {
    				append(div1, t0);
    			}

    			else {
    				default_slot.m(div1, null);
    			}

    			append(div1, t1);
    			append(div1, div0);
    			append(div0, t2);
    			append(div0, t3);
    			append(div0, button0);
    			append(div0, t5);
    			append(div0, button1);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (default_slot && default_slot.p && changed.$$scope) {
    				default_slot.p(get_slot_changes(default_slot_1, ctx, changed, null), get_slot_context(default_slot_1, ctx, null));
    			}

    			if (!current || changed.value) {
    				set_data(t2, ctx.value);
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			if (default_slot && default_slot.i) default_slot.i(local);
    			current = true;
    		},

    		o: function outro(local) {
    			if (default_slot && default_slot.o) default_slot.o(local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div1);
    			}

    			if (default_slot) default_slot.d(detaching);
    			run_all(dispose);
    		}
    	};
    }

    function instance($$self, $$props, $$invalidate) {
    	let { value = 0, step = 1 } = $$props;

    	const writable_props = ['value', 'step'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Counter> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;

    	function click_handler() {
    		const $$result = (value += step);
    		$$invalidate('value', value);
    		return $$result;
    	}

    	function click_handler_1() {
    		const $$result = (value -= step);
    		$$invalidate('value', value);
    		return $$result;
    	}

    	$$self.$set = $$props => {
    		if ('value' in $$props) $$invalidate('value', value = $$props.value);
    		if ('step' in $$props) $$invalidate('step', step = $$props.step);
    		if ('$$scope' in $$props) $$invalidate('$$scope', $$scope = $$props.$$scope);
    	};

    	return {
    		value,
    		step,
    		click_handler,
    		click_handler_1,
    		$$slots,
    		$$scope
    	};
    }

    class Counter extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance, create_fragment, safe_not_equal, ["value", "step"]);
    	}

    	get value() {
    		throw new Error("<Counter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<Counter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get step() {
    		throw new Error("<Counter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set step(value) {
    		throw new Error("<Counter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/App.svelte generated by Svelte v3.4.4 */

    const file$1 = "src/App.svelte";

    // (5:2) <Counter value={1}>
    function create_default_slot_1(ctx) {
    	var t;

    	return {
    		c: function create() {
    			t = text("Counter 1");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t, anchor);
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t);
    			}
    		}
    	};
    }

    // (6:2) <Counter value={$count} step={3}>
    function create_default_slot(ctx) {
    	var t;

    	return {
    		c: function create() {
    			t = text("Counter 2");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t, anchor);
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t);
    			}
    		}
    	};
    }

    function create_fragment$1(ctx) {
    	var div, h1, t0, t1, t2, t3, p, t4, t5, current;

    	var counter0 = new Counter({ $$inline: true });

    	var counter1 = new Counter({
    		props: {
    		value: 1,
    		$$slots: { default: [create_default_slot_1] },
    		$$scope: { ctx }
    	},
    		$$inline: true
    	});

    	var counter2 = new Counter({
    		props: {
    		value: ctx.$count,
    		step: 3,
    		$$slots: { default: [create_default_slot] },
    		$$scope: { ctx }
    	},
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			div = element("div");
    			h1 = element("h1");
    			t0 = text("Hello ");
    			t1 = text(ctx.name);
    			t2 = text("!");
    			t3 = space();
    			p = element("p");
    			counter0.$$.fragment.c();
    			t4 = space();
    			counter1.$$.fragment.c();
    			t5 = space();
    			counter2.$$.fragment.c();
    			h1.className = "svelte-1ucbz36";
    			add_location(h1, file$1, 1, 0, 6);
    			add_location(p, file$1, 2, 0, 29);
    			add_location(div, file$1, 0, 0, 0);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			append(div, h1);
    			append(h1, t0);
    			append(h1, t1);
    			append(h1, t2);
    			append(div, t3);
    			append(div, p);
    			mount_component(counter0, p, null);
    			append(p, t4);
    			mount_component(counter1, p, null);
    			append(p, t5);
    			mount_component(counter2, p, null);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (!current || changed.name) {
    				set_data(t1, ctx.name);
    			}

    			var counter1_changes = {};
    			if (changed.$$scope) counter1_changes.$$scope = { changed, ctx };
    			counter1.$set(counter1_changes);

    			var counter2_changes = {};
    			if (changed.$count) counter2_changes.value = ctx.$count;
    			if (changed.$$scope) counter2_changes.$$scope = { changed, ctx };
    			counter2.$set(counter2_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			counter0.$$.fragment.i(local);

    			counter1.$$.fragment.i(local);

    			counter2.$$.fragment.i(local);

    			current = true;
    		},

    		o: function outro(local) {
    			counter0.$$.fragment.o(local);
    			counter1.$$.fragment.o(local);
    			counter2.$$.fragment.o(local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div);
    			}

    			counter0.$destroy();

    			counter1.$destroy();

    			counter2.$destroy();
    		}
    	};
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let $count;

    	
    const count = writable(100); validate_store(count, 'count'); subscribe($$self, count, $$value => { $count = $$value; $$invalidate('$count', $count); });
    let { name } = $$props;
    onMount(() => {
        console.log("App mounted");
    });

    	const writable_props = ['name'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ('name' in $$props) $$invalidate('name', name = $$props.name);
    	};

    	return { count, name, $count };
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1, create_fragment$1, safe_not_equal, ["name"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.name === undefined && !('name' in props)) {
    			console.warn("<App> was created without expected prop 'name'");
    		}
    	}

    	get name() {
    		throw new Error("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const app = new App({
        target: document.body,
        props: {
            name: "world"
        }
    });

    return app;

}());
//# sourceMappingURL=bundle.js.map


/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2J1bmRsZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO1FBQUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7OztRQUdBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwwQ0FBMEMsZ0NBQWdDO1FBQzFFO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0Esd0RBQXdELGtCQUFrQjtRQUMxRTtRQUNBLGlEQUFpRCxjQUFjO1FBQy9EOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSx5Q0FBeUMsaUNBQWlDO1FBQzFFLGdIQUFnSCxtQkFBbUIsRUFBRTtRQUNySTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDJCQUEyQiwwQkFBMEIsRUFBRTtRQUN2RCxpQ0FBaUMsZUFBZTtRQUNoRDtRQUNBO1FBQ0E7O1FBRUE7UUFDQSxzREFBc0QsK0RBQStEOztRQUVySDtRQUNBOzs7UUFHQTtRQUNBOzs7Ozs7Ozs7Ozs7QUNsRkE7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsS0FBSztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix5REFBeUQ7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0NBQWtDLHFDQUFxQztBQUM5RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLCtDQUErQztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsZUFBZSxtQkFBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxzQkFBc0I7O0FBRWhDO0FBQ0E7QUFDQSwySEFBMkgsSUFBSTtBQUMvSCxNQUFNOztBQUVOLFVBQVUsYUFBYSxXQUFXOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSw2QkFBNkIsRUFBRTtBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCLE9BQU8sT0FBTyxFQUFFO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlDQUFpQyxpQkFBaUI7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQ0FBbUM7QUFDbkQsZ0JBQWdCO0FBQ2hCLE1BQU07QUFDTjtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUNBQWlDO0FBQ2pELGdCQUFnQjtBQUNoQixNQUFNO0FBQ047QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3REFBd0Q7QUFDeEQ7O0FBRUE7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQSxnQ0FBZ0MsZ0NBQWdDLHNDQUFzQyxrQkFBa0IsZ0NBQWdDLEVBQUU7QUFDMUosU0FBUyxPQUFPO0FBQ2hCO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSx1SEFBdUgsSUFBSTtBQUMzSCxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLENBQUM7QUFDRCIsImZpbGUiOiJ1aS5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vcHVibGljL2J1bmRsZS5qc1wiKTtcbiIsInZhciBhcHAgPSAoZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGZ1bmN0aW9uIG5vb3AoKSB7IH1cbiAgICBmdW5jdGlvbiBhc3NpZ24odGFyLCBzcmMpIHtcbiAgICAgICAgZm9yIChjb25zdCBrIGluIHNyYylcbiAgICAgICAgICAgIHRhcltrXSA9IHNyY1trXTtcbiAgICAgICAgcmV0dXJuIHRhcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkX2xvY2F0aW9uKGVsZW1lbnQsIGZpbGUsIGxpbmUsIGNvbHVtbiwgY2hhcikge1xuICAgICAgICBlbGVtZW50Ll9fc3ZlbHRlX21ldGEgPSB7XG4gICAgICAgICAgICBsb2M6IHsgZmlsZSwgbGluZSwgY29sdW1uLCBjaGFyIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcnVuKGZuKSB7XG4gICAgICAgIHJldHVybiBmbigpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBibGFua19vYmplY3QoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBydW5fYWxsKGZucykge1xuICAgICAgICBmbnMuZm9yRWFjaChydW4pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc19mdW5jdGlvbih0aGluZykge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHRoaW5nID09PSAnZnVuY3Rpb24nO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzYWZlX25vdF9lcXVhbChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhICE9IGEgPyBiID09IGIgOiBhICE9PSBiIHx8ICgoYSAmJiB0eXBlb2YgYSA9PT0gJ29iamVjdCcpIHx8IHR5cGVvZiBhID09PSAnZnVuY3Rpb24nKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVfc3RvcmUoc3RvcmUsIG5hbWUpIHtcbiAgICAgICAgaWYgKCFzdG9yZSB8fCB0eXBlb2Ygc3RvcmUuc3Vic2NyaWJlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCcke25hbWV9JyBpcyBub3QgYSBzdG9yZSB3aXRoIGEgJ3N1YnNjcmliZScgbWV0aG9kYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc3Vic2NyaWJlKGNvbXBvbmVudCwgc3RvcmUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IHVuc3ViID0gc3RvcmUuc3Vic2NyaWJlKGNhbGxiYWNrKTtcbiAgICAgICAgY29tcG9uZW50LiQkLm9uX2Rlc3Ryb3kucHVzaCh1bnN1Yi51bnN1YnNjcmliZVxuICAgICAgICAgICAgPyAoKSA9PiB1bnN1Yi51bnN1YnNjcmliZSgpXG4gICAgICAgICAgICA6IHVuc3ViKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlX3Nsb3QoZGVmaW5pdGlvbiwgY3R4LCBmbikge1xuICAgICAgICBpZiAoZGVmaW5pdGlvbikge1xuICAgICAgICAgICAgY29uc3Qgc2xvdF9jdHggPSBnZXRfc2xvdF9jb250ZXh0KGRlZmluaXRpb24sIGN0eCwgZm4pO1xuICAgICAgICAgICAgcmV0dXJuIGRlZmluaXRpb25bMF0oc2xvdF9jdHgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldF9zbG90X2NvbnRleHQoZGVmaW5pdGlvbiwgY3R4LCBmbikge1xuICAgICAgICByZXR1cm4gZGVmaW5pdGlvblsxXVxuICAgICAgICAgICAgPyBhc3NpZ24oe30sIGFzc2lnbihjdHguJCRzY29wZS5jdHgsIGRlZmluaXRpb25bMV0oZm4gPyBmbihjdHgpIDoge30pKSlcbiAgICAgICAgICAgIDogY3R4LiQkc2NvcGUuY3R4O1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRfc2xvdF9jaGFuZ2VzKGRlZmluaXRpb24sIGN0eCwgY2hhbmdlZCwgZm4pIHtcbiAgICAgICAgcmV0dXJuIGRlZmluaXRpb25bMV1cbiAgICAgICAgICAgID8gYXNzaWduKHt9LCBhc3NpZ24oY3R4LiQkc2NvcGUuY2hhbmdlZCB8fCB7fSwgZGVmaW5pdGlvblsxXShmbiA/IGZuKGNoYW5nZWQpIDoge30pKSlcbiAgICAgICAgICAgIDogY3R4LiQkc2NvcGUuY2hhbmdlZCB8fCB7fTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcHBlbmQodGFyZ2V0LCBub2RlKSB7XG4gICAgICAgIHRhcmdldC5hcHBlbmRDaGlsZChub2RlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW5zZXJ0KHRhcmdldCwgbm9kZSwgYW5jaG9yKSB7XG4gICAgICAgIHRhcmdldC5pbnNlcnRCZWZvcmUobm9kZSwgYW5jaG9yIHx8IG51bGwpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXRhY2gobm9kZSkge1xuICAgICAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVsZW1lbnQobmFtZSkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGV4dChkYXRhKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShkYXRhKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3BhY2UoKSB7XG4gICAgICAgIHJldHVybiB0ZXh0KCcgJyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxpc3Rlbihub2RlLCBldmVudCwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gKCkgPT4gbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hpbGRyZW4oZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShlbGVtZW50LmNoaWxkTm9kZXMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRfZGF0YSh0ZXh0LCBkYXRhKSB7XG4gICAgICAgIGRhdGEgPSAnJyArIGRhdGE7XG4gICAgICAgIGlmICh0ZXh0LmRhdGEgIT09IGRhdGEpXG4gICAgICAgICAgICB0ZXh0LmRhdGEgPSBkYXRhO1xuICAgIH1cblxuICAgIGxldCBjdXJyZW50X2NvbXBvbmVudDtcbiAgICBmdW5jdGlvbiBzZXRfY3VycmVudF9jb21wb25lbnQoY29tcG9uZW50KSB7XG4gICAgICAgIGN1cnJlbnRfY29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRfY3VycmVudF9jb21wb25lbnQoKSB7XG4gICAgICAgIGlmICghY3VycmVudF9jb21wb25lbnQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZ1bmN0aW9uIGNhbGxlZCBvdXRzaWRlIGNvbXBvbmVudCBpbml0aWFsaXphdGlvbmApO1xuICAgICAgICByZXR1cm4gY3VycmVudF9jb21wb25lbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uTW91bnQoZm4pIHtcbiAgICAgICAgZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQub25fbW91bnQucHVzaChmbik7XG4gICAgfVxuXG4gICAgY29uc3QgZGlydHlfY29tcG9uZW50cyA9IFtdO1xuICAgIGNvbnN0IHJlc29sdmVkX3Byb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICBsZXQgdXBkYXRlX3NjaGVkdWxlZCA9IGZhbHNlO1xuICAgIGNvbnN0IGJpbmRpbmdfY2FsbGJhY2tzID0gW107XG4gICAgY29uc3QgcmVuZGVyX2NhbGxiYWNrcyA9IFtdO1xuICAgIGNvbnN0IGZsdXNoX2NhbGxiYWNrcyA9IFtdO1xuICAgIGZ1bmN0aW9uIHNjaGVkdWxlX3VwZGF0ZSgpIHtcbiAgICAgICAgaWYgKCF1cGRhdGVfc2NoZWR1bGVkKSB7XG4gICAgICAgICAgICB1cGRhdGVfc2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlc29sdmVkX3Byb21pc2UudGhlbihmbHVzaCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkX3JlbmRlcl9jYWxsYmFjayhmbikge1xuICAgICAgICByZW5kZXJfY2FsbGJhY2tzLnB1c2goZm4pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICAgICAgY29uc3Qgc2Vlbl9jYWxsYmFja3MgPSBuZXcgU2V0KCk7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIC8vIGZpcnN0LCBjYWxsIGJlZm9yZVVwZGF0ZSBmdW5jdGlvbnNcbiAgICAgICAgICAgIC8vIGFuZCB1cGRhdGUgY29tcG9uZW50c1xuICAgICAgICAgICAgd2hpbGUgKGRpcnR5X2NvbXBvbmVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tcG9uZW50ID0gZGlydHlfY29tcG9uZW50cy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChjb21wb25lbnQpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZShjb21wb25lbnQuJCQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGJpbmRpbmdfY2FsbGJhY2tzLmxlbmd0aClcbiAgICAgICAgICAgICAgICBiaW5kaW5nX2NhbGxiYWNrcy5zaGlmdCgpKCk7XG4gICAgICAgICAgICAvLyB0aGVuLCBvbmNlIGNvbXBvbmVudHMgYXJlIHVwZGF0ZWQsIGNhbGxcbiAgICAgICAgICAgIC8vIGFmdGVyVXBkYXRlIGZ1bmN0aW9ucy4gVGhpcyBtYXkgY2F1c2VcbiAgICAgICAgICAgIC8vIHN1YnNlcXVlbnQgdXBkYXRlcy4uLlxuICAgICAgICAgICAgd2hpbGUgKHJlbmRlcl9jYWxsYmFja3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSByZW5kZXJfY2FsbGJhY2tzLnBvcCgpO1xuICAgICAgICAgICAgICAgIGlmICghc2Vlbl9jYWxsYmFja3MuaGFzKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICAvLyAuLi5zbyBndWFyZCBhZ2FpbnN0IGluZmluaXRlIGxvb3BzXG4gICAgICAgICAgICAgICAgICAgIHNlZW5fY2FsbGJhY2tzLmFkZChjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChkaXJ0eV9jb21wb25lbnRzLmxlbmd0aCk7XG4gICAgICAgIHdoaWxlIChmbHVzaF9jYWxsYmFja3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBmbHVzaF9jYWxsYmFja3MucG9wKCkoKTtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVfc2NoZWR1bGVkID0gZmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZSgkJCkge1xuICAgICAgICBpZiAoJCQuZnJhZ21lbnQpIHtcbiAgICAgICAgICAgICQkLnVwZGF0ZSgkJC5kaXJ0eSk7XG4gICAgICAgICAgICBydW5fYWxsKCQkLmJlZm9yZV9yZW5kZXIpO1xuICAgICAgICAgICAgJCQuZnJhZ21lbnQucCgkJC5kaXJ0eSwgJCQuY3R4KTtcbiAgICAgICAgICAgICQkLmRpcnR5ID0gbnVsbDtcbiAgICAgICAgICAgICQkLmFmdGVyX3JlbmRlci5mb3JFYWNoKGFkZF9yZW5kZXJfY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50X2NvbXBvbmVudChjb21wb25lbnQsIHRhcmdldCwgYW5jaG9yKSB7XG4gICAgICAgIGNvbnN0IHsgZnJhZ21lbnQsIG9uX21vdW50LCBvbl9kZXN0cm95LCBhZnRlcl9yZW5kZXIgfSA9IGNvbXBvbmVudC4kJDtcbiAgICAgICAgZnJhZ21lbnQubSh0YXJnZXQsIGFuY2hvcik7XG4gICAgICAgIC8vIG9uTW91bnQgaGFwcGVucyBhZnRlciB0aGUgaW5pdGlhbCBhZnRlclVwZGF0ZS4gQmVjYXVzZVxuICAgICAgICAvLyBhZnRlclVwZGF0ZSBjYWxsYmFja3MgaGFwcGVuIGluIHJldmVyc2Ugb3JkZXIgKGlubmVyIGZpcnN0KVxuICAgICAgICAvLyB3ZSBzY2hlZHVsZSBvbk1vdW50IGNhbGxiYWNrcyBiZWZvcmUgYWZ0ZXJVcGRhdGUgY2FsbGJhY2tzXG4gICAgICAgIGFkZF9yZW5kZXJfY2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV3X29uX2Rlc3Ryb3kgPSBvbl9tb3VudC5tYXAocnVuKS5maWx0ZXIoaXNfZnVuY3Rpb24pO1xuICAgICAgICAgICAgaWYgKG9uX2Rlc3Ryb3kpIHtcbiAgICAgICAgICAgICAgICBvbl9kZXN0cm95LnB1c2goLi4ubmV3X29uX2Rlc3Ryb3kpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRWRnZSBjYXNlIC0gY29tcG9uZW50IHdhcyBkZXN0cm95ZWQgaW1tZWRpYXRlbHksXG4gICAgICAgICAgICAgICAgLy8gbW9zdCBsaWtlbHkgYXMgYSByZXN1bHQgb2YgYSBiaW5kaW5nIGluaXRpYWxpc2luZ1xuICAgICAgICAgICAgICAgIHJ1bl9hbGwobmV3X29uX2Rlc3Ryb3kpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29tcG9uZW50LiQkLm9uX21vdW50ID0gW107XG4gICAgICAgIH0pO1xuICAgICAgICBhZnRlcl9yZW5kZXIuZm9yRWFjaChhZGRfcmVuZGVyX2NhbGxiYWNrKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzdHJveShjb21wb25lbnQsIGRldGFjaGluZykge1xuICAgICAgICBpZiAoY29tcG9uZW50LiQkKSB7XG4gICAgICAgICAgICBydW5fYWxsKGNvbXBvbmVudC4kJC5vbl9kZXN0cm95KTtcbiAgICAgICAgICAgIGNvbXBvbmVudC4kJC5mcmFnbWVudC5kKGRldGFjaGluZyk7XG4gICAgICAgICAgICAvLyBUT0RPIG51bGwgb3V0IG90aGVyIHJlZnMsIGluY2x1ZGluZyBjb21wb25lbnQuJCQgKGJ1dCBuZWVkIHRvXG4gICAgICAgICAgICAvLyBwcmVzZXJ2ZSBmaW5hbCBzdGF0ZT8pXG4gICAgICAgICAgICBjb21wb25lbnQuJCQub25fZGVzdHJveSA9IGNvbXBvbmVudC4kJC5mcmFnbWVudCA9IG51bGw7XG4gICAgICAgICAgICBjb21wb25lbnQuJCQuY3R4ID0ge307XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbWFrZV9kaXJ0eShjb21wb25lbnQsIGtleSkge1xuICAgICAgICBpZiAoIWNvbXBvbmVudC4kJC5kaXJ0eSkge1xuICAgICAgICAgICAgZGlydHlfY29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XG4gICAgICAgICAgICBzY2hlZHVsZV91cGRhdGUoKTtcbiAgICAgICAgICAgIGNvbXBvbmVudC4kJC5kaXJ0eSA9IGJsYW5rX29iamVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbXBvbmVudC4kJC5kaXJ0eVtrZXldID0gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW5pdChjb21wb25lbnQsIG9wdGlvbnMsIGluc3RhbmNlLCBjcmVhdGVfZnJhZ21lbnQsIG5vdF9lcXVhbCQkMSwgcHJvcF9uYW1lcykge1xuICAgICAgICBjb25zdCBwYXJlbnRfY29tcG9uZW50ID0gY3VycmVudF9jb21wb25lbnQ7XG4gICAgICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChjb21wb25lbnQpO1xuICAgICAgICBjb25zdCBwcm9wcyA9IG9wdGlvbnMucHJvcHMgfHwge307XG4gICAgICAgIGNvbnN0ICQkID0gY29tcG9uZW50LiQkID0ge1xuICAgICAgICAgICAgZnJhZ21lbnQ6IG51bGwsXG4gICAgICAgICAgICBjdHg6IG51bGwsXG4gICAgICAgICAgICAvLyBzdGF0ZVxuICAgICAgICAgICAgcHJvcHM6IHByb3BfbmFtZXMsXG4gICAgICAgICAgICB1cGRhdGU6IG5vb3AsXG4gICAgICAgICAgICBub3RfZXF1YWw6IG5vdF9lcXVhbCQkMSxcbiAgICAgICAgICAgIGJvdW5kOiBibGFua19vYmplY3QoKSxcbiAgICAgICAgICAgIC8vIGxpZmVjeWNsZVxuICAgICAgICAgICAgb25fbW91bnQ6IFtdLFxuICAgICAgICAgICAgb25fZGVzdHJveTogW10sXG4gICAgICAgICAgICBiZWZvcmVfcmVuZGVyOiBbXSxcbiAgICAgICAgICAgIGFmdGVyX3JlbmRlcjogW10sXG4gICAgICAgICAgICBjb250ZXh0OiBuZXcgTWFwKHBhcmVudF9jb21wb25lbnQgPyBwYXJlbnRfY29tcG9uZW50LiQkLmNvbnRleHQgOiBbXSksXG4gICAgICAgICAgICAvLyBldmVyeXRoaW5nIGVsc2VcbiAgICAgICAgICAgIGNhbGxiYWNrczogYmxhbmtfb2JqZWN0KCksXG4gICAgICAgICAgICBkaXJ0eTogbnVsbFxuICAgICAgICB9O1xuICAgICAgICBsZXQgcmVhZHkgPSBmYWxzZTtcbiAgICAgICAgJCQuY3R4ID0gaW5zdGFuY2VcbiAgICAgICAgICAgID8gaW5zdGFuY2UoY29tcG9uZW50LCBwcm9wcywgKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoJCQuY3R4ICYmIG5vdF9lcXVhbCQkMSgkJC5jdHhba2V5XSwgJCQuY3R4W2tleV0gPSB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCQkLmJvdW5kW2tleV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAkJC5ib3VuZFtrZXldKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlYWR5KVxuICAgICAgICAgICAgICAgICAgICAgICAgbWFrZV9kaXJ0eShjb21wb25lbnQsIGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIDogcHJvcHM7XG4gICAgICAgICQkLnVwZGF0ZSgpO1xuICAgICAgICByZWFkeSA9IHRydWU7XG4gICAgICAgIHJ1bl9hbGwoJCQuYmVmb3JlX3JlbmRlcik7XG4gICAgICAgICQkLmZyYWdtZW50ID0gY3JlYXRlX2ZyYWdtZW50KCQkLmN0eCk7XG4gICAgICAgIGlmIChvcHRpb25zLnRhcmdldCkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaHlkcmF0ZSkge1xuICAgICAgICAgICAgICAgICQkLmZyYWdtZW50LmwoY2hpbGRyZW4ob3B0aW9ucy50YXJnZXQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICQkLmZyYWdtZW50LmMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmludHJvICYmIGNvbXBvbmVudC4kJC5mcmFnbWVudC5pKVxuICAgICAgICAgICAgICAgIGNvbXBvbmVudC4kJC5mcmFnbWVudC5pKCk7XG4gICAgICAgICAgICBtb3VudF9jb21wb25lbnQoY29tcG9uZW50LCBvcHRpb25zLnRhcmdldCwgb3B0aW9ucy5hbmNob3IpO1xuICAgICAgICAgICAgZmx1c2goKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRfY3VycmVudF9jb21wb25lbnQocGFyZW50X2NvbXBvbmVudCk7XG4gICAgfVxuICAgIGNsYXNzIFN2ZWx0ZUNvbXBvbmVudCB7XG4gICAgICAgICRkZXN0cm95KCkge1xuICAgICAgICAgICAgZGVzdHJveSh0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuJGRlc3Ryb3kgPSBub29wO1xuICAgICAgICB9XG4gICAgICAgICRvbih0eXBlLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gKHRoaXMuJCQuY2FsbGJhY2tzW3R5cGVdIHx8ICh0aGlzLiQkLmNhbGxiYWNrc1t0eXBlXSA9IFtdKSk7XG4gICAgICAgICAgICBjYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gY2FsbGJhY2tzLmluZGV4T2YoY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAkc2V0KCkge1xuICAgICAgICAgICAgLy8gb3ZlcnJpZGRlbiBieSBpbnN0YW5jZSwgaWYgaXQgaGFzIHByb3BzXG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xhc3MgU3ZlbHRlQ29tcG9uZW50RGV2IGV4dGVuZHMgU3ZlbHRlQ29tcG9uZW50IHtcbiAgICAgICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zIHx8ICghb3B0aW9ucy50YXJnZXQgJiYgIW9wdGlvbnMuJCRpbmxpbmUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAndGFyZ2V0JyBpcyBhIHJlcXVpcmVkIG9wdGlvbmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgfVxuICAgICAgICAkZGVzdHJveSgpIHtcbiAgICAgICAgICAgIHN1cGVyLiRkZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLiRkZXN0cm95ID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgQ29tcG9uZW50IHdhcyBhbHJlYWR5IGRlc3Ryb3llZGApOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBgV3JpdGFibGVgIHN0b3JlIHRoYXQgYWxsb3dzIGJvdGggdXBkYXRpbmcgYW5kIHJlYWRpbmcgYnkgc3Vic2NyaXB0aW9uLlxuICAgICAqIEBwYXJhbSB7Kj19dmFsdWUgaW5pdGlhbCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RhcnRTdG9wTm90aWZpZXI9fXN0YXJ0IHN0YXJ0IGFuZCBzdG9wIG5vdGlmaWNhdGlvbnMgZm9yIHN1YnNjcmlwdGlvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cml0YWJsZSh2YWx1ZSwgc3RhcnQgPSBub29wKSB7XG4gICAgICAgIGxldCBzdG9wO1xuICAgICAgICBjb25zdCBzdWJzY3JpYmVycyA9IFtdO1xuICAgICAgICBmdW5jdGlvbiBzZXQobmV3X3ZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoc2FmZV9ub3RfZXF1YWwodmFsdWUsIG5ld192YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ld192YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIXN0b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBub3QgcmVhZHlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlcnMuZm9yRWFjaCgocykgPT4gc1sxXSgpKTtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVycy5mb3JFYWNoKChzKSA9PiBzWzBdKHZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlKGZuKSB7XG4gICAgICAgICAgICBzZXQoZm4odmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzdWJzY3JpYmUocnVuLCBpbnZhbGlkYXRlID0gbm9vcCkge1xuICAgICAgICAgICAgY29uc3Qgc3Vic2NyaWJlciA9IFtydW4sIGludmFsaWRhdGVdO1xuICAgICAgICAgICAgc3Vic2NyaWJlcnMucHVzaChzdWJzY3JpYmVyKTtcbiAgICAgICAgICAgIGlmIChzdWJzY3JpYmVycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBzdG9wID0gc3RhcnQoc2V0KSB8fCBub29wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcnVuKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBzdWJzY3JpYmVycy5pbmRleE9mKHN1YnNjcmliZXIpO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN1YnNjcmliZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzdG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzZXQsIHVwZGF0ZSwgc3Vic2NyaWJlIH07XG4gICAgfVxuXG4gICAgLyogc3JjL0NvdW50ZXIuc3ZlbHRlIGdlbmVyYXRlZCBieSBTdmVsdGUgdjMuNC40ICovXG5cbiAgICBjb25zdCBmaWxlID0gXCJzcmMvQ291bnRlci5zdmVsdGVcIjtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZV9mcmFnbWVudChjdHgpIHtcbiAgICBcdHZhciBkaXYxLCB0MCwgdDEsIGRpdjAsIHQyLCB0MywgYnV0dG9uMCwgdDUsIGJ1dHRvbjEsIGN1cnJlbnQsIGRpc3Bvc2U7XG5cbiAgICBcdGNvbnN0IGRlZmF1bHRfc2xvdF8xID0gY3R4LiQkc2xvdHMuZGVmYXVsdDtcbiAgICBcdGNvbnN0IGRlZmF1bHRfc2xvdCA9IGNyZWF0ZV9zbG90KGRlZmF1bHRfc2xvdF8xLCBjdHgsIG51bGwpO1xuXG4gICAgXHRyZXR1cm4ge1xuICAgIFx0XHRjOiBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgXHRcdFx0ZGl2MSA9IGVsZW1lbnQoXCJkaXZcIik7XG5cbiAgICBcdFx0XHRpZiAoIWRlZmF1bHRfc2xvdCkge1xuICAgIFx0XHRcdFx0dDAgPSB0ZXh0KFwiRGVmYXVsdCBDb3VudGVyXCIpO1xuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGlmIChkZWZhdWx0X3Nsb3QpIGRlZmF1bHRfc2xvdC5jKCk7XG4gICAgXHRcdFx0dDEgPSBzcGFjZSgpO1xuICAgIFx0XHRcdGRpdjAgPSBlbGVtZW50KFwiZGl2XCIpO1xuICAgIFx0XHRcdHQyID0gdGV4dChjdHgudmFsdWUpO1xuICAgIFx0XHRcdHQzID0gc3BhY2UoKTtcbiAgICBcdFx0XHRidXR0b24wID0gZWxlbWVudChcImJ1dHRvblwiKTtcbiAgICBcdFx0XHRidXR0b24wLnRleHRDb250ZW50ID0gXCIrXCI7XG4gICAgXHRcdFx0dDUgPSBzcGFjZSgpO1xuICAgIFx0XHRcdGJ1dHRvbjEgPSBlbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgIFx0XHRcdGJ1dHRvbjEudGV4dENvbnRlbnQgPSBcIi1cIjtcblxuICAgIFx0XHRcdGFkZF9sb2NhdGlvbihidXR0b24wLCBmaWxlLCA0LCA0LCA2MSk7XG4gICAgXHRcdFx0YWRkX2xvY2F0aW9uKGJ1dHRvbjEsIGZpbGUsIDUsIDQsIDExNyk7XG4gICAgXHRcdFx0YWRkX2xvY2F0aW9uKGRpdjAsIGZpbGUsIDIsIDIsIDM5KTtcbiAgICBcdFx0XHRhZGRfbG9jYXRpb24oZGl2MSwgZmlsZSwgMCwgMCwgMCk7XG5cbiAgICBcdFx0XHRkaXNwb3NlID0gW1xuICAgIFx0XHRcdFx0bGlzdGVuKGJ1dHRvbjAsIFwiY2xpY2tcIiwgY3R4LmNsaWNrX2hhbmRsZXIpLFxuICAgIFx0XHRcdFx0bGlzdGVuKGJ1dHRvbjEsIFwiY2xpY2tcIiwgY3R4LmNsaWNrX2hhbmRsZXJfMSlcbiAgICBcdFx0XHRdO1xuICAgIFx0XHR9LFxuXG4gICAgXHRcdGw6IGZ1bmN0aW9uIGNsYWltKG5vZGVzKSB7XG4gICAgXHRcdFx0aWYgKGRlZmF1bHRfc2xvdCkgZGVmYXVsdF9zbG90LmwoZGl2MV9ub2Rlcyk7XG4gICAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwib3B0aW9ucy5oeWRyYXRlIG9ubHkgd29ya3MgaWYgdGhlIGNvbXBvbmVudCB3YXMgY29tcGlsZWQgd2l0aCB0aGUgYGh5ZHJhdGFibGU6IHRydWVgIG9wdGlvblwiKTtcbiAgICBcdFx0fSxcblxuICAgIFx0XHRtOiBmdW5jdGlvbiBtb3VudCh0YXJnZXQsIGFuY2hvcikge1xuICAgIFx0XHRcdGluc2VydCh0YXJnZXQsIGRpdjEsIGFuY2hvcik7XG5cbiAgICBcdFx0XHRpZiAoIWRlZmF1bHRfc2xvdCkge1xuICAgIFx0XHRcdFx0YXBwZW5kKGRpdjEsIHQwKTtcbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRlbHNlIHtcbiAgICBcdFx0XHRcdGRlZmF1bHRfc2xvdC5tKGRpdjEsIG51bGwpO1xuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGFwcGVuZChkaXYxLCB0MSk7XG4gICAgXHRcdFx0YXBwZW5kKGRpdjEsIGRpdjApO1xuICAgIFx0XHRcdGFwcGVuZChkaXYwLCB0Mik7XG4gICAgXHRcdFx0YXBwZW5kKGRpdjAsIHQzKTtcbiAgICBcdFx0XHRhcHBlbmQoZGl2MCwgYnV0dG9uMCk7XG4gICAgXHRcdFx0YXBwZW5kKGRpdjAsIHQ1KTtcbiAgICBcdFx0XHRhcHBlbmQoZGl2MCwgYnV0dG9uMSk7XG4gICAgXHRcdFx0Y3VycmVudCA9IHRydWU7XG4gICAgXHRcdH0sXG5cbiAgICBcdFx0cDogZnVuY3Rpb24gdXBkYXRlKGNoYW5nZWQsIGN0eCkge1xuICAgIFx0XHRcdGlmIChkZWZhdWx0X3Nsb3QgJiYgZGVmYXVsdF9zbG90LnAgJiYgY2hhbmdlZC4kJHNjb3BlKSB7XG4gICAgXHRcdFx0XHRkZWZhdWx0X3Nsb3QucChnZXRfc2xvdF9jaGFuZ2VzKGRlZmF1bHRfc2xvdF8xLCBjdHgsIGNoYW5nZWQsIG51bGwpLCBnZXRfc2xvdF9jb250ZXh0KGRlZmF1bHRfc2xvdF8xLCBjdHgsIG51bGwpKTtcbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRpZiAoIWN1cnJlbnQgfHwgY2hhbmdlZC52YWx1ZSkge1xuICAgIFx0XHRcdFx0c2V0X2RhdGEodDIsIGN0eC52YWx1ZSk7XG4gICAgXHRcdFx0fVxuICAgIFx0XHR9LFxuXG4gICAgXHRcdGk6IGZ1bmN0aW9uIGludHJvKGxvY2FsKSB7XG4gICAgXHRcdFx0aWYgKGN1cnJlbnQpIHJldHVybjtcbiAgICBcdFx0XHRpZiAoZGVmYXVsdF9zbG90ICYmIGRlZmF1bHRfc2xvdC5pKSBkZWZhdWx0X3Nsb3QuaShsb2NhbCk7XG4gICAgXHRcdFx0Y3VycmVudCA9IHRydWU7XG4gICAgXHRcdH0sXG5cbiAgICBcdFx0bzogZnVuY3Rpb24gb3V0cm8obG9jYWwpIHtcbiAgICBcdFx0XHRpZiAoZGVmYXVsdF9zbG90ICYmIGRlZmF1bHRfc2xvdC5vKSBkZWZhdWx0X3Nsb3Qubyhsb2NhbCk7XG4gICAgXHRcdFx0Y3VycmVudCA9IGZhbHNlO1xuICAgIFx0XHR9LFxuXG4gICAgXHRcdGQ6IGZ1bmN0aW9uIGRlc3Ryb3koZGV0YWNoaW5nKSB7XG4gICAgXHRcdFx0aWYgKGRldGFjaGluZykge1xuICAgIFx0XHRcdFx0ZGV0YWNoKGRpdjEpO1xuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGlmIChkZWZhdWx0X3Nsb3QpIGRlZmF1bHRfc2xvdC5kKGRldGFjaGluZyk7XG4gICAgXHRcdFx0cnVuX2FsbChkaXNwb3NlKTtcbiAgICBcdFx0fVxuICAgIFx0fTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YW5jZSgkJHNlbGYsICQkcHJvcHMsICQkaW52YWxpZGF0ZSkge1xuICAgIFx0bGV0IHsgdmFsdWUgPSAwLCBzdGVwID0gMSB9ID0gJCRwcm9wcztcblxuICAgIFx0Y29uc3Qgd3JpdGFibGVfcHJvcHMgPSBbJ3ZhbHVlJywgJ3N0ZXAnXTtcbiAgICBcdE9iamVjdC5rZXlzKCQkcHJvcHMpLmZvckVhY2goa2V5ID0+IHtcbiAgICBcdFx0aWYgKCF3cml0YWJsZV9wcm9wcy5pbmNsdWRlcyhrZXkpICYmICFrZXkuc3RhcnRzV2l0aCgnJCQnKSkgY29uc29sZS53YXJuKGA8Q291bnRlcj4gd2FzIGNyZWF0ZWQgd2l0aCB1bmtub3duIHByb3AgJyR7a2V5fSdgKTtcbiAgICBcdH0pO1xuXG4gICAgXHRsZXQgeyAkJHNsb3RzID0ge30sICQkc2NvcGUgfSA9ICQkcHJvcHM7XG5cbiAgICBcdGZ1bmN0aW9uIGNsaWNrX2hhbmRsZXIoKSB7XG4gICAgXHRcdGNvbnN0ICQkcmVzdWx0ID0gKHZhbHVlICs9IHN0ZXApO1xuICAgIFx0XHQkJGludmFsaWRhdGUoJ3ZhbHVlJywgdmFsdWUpO1xuICAgIFx0XHRyZXR1cm4gJCRyZXN1bHQ7XG4gICAgXHR9XG5cbiAgICBcdGZ1bmN0aW9uIGNsaWNrX2hhbmRsZXJfMSgpIHtcbiAgICBcdFx0Y29uc3QgJCRyZXN1bHQgPSAodmFsdWUgLT0gc3RlcCk7XG4gICAgXHRcdCQkaW52YWxpZGF0ZSgndmFsdWUnLCB2YWx1ZSk7XG4gICAgXHRcdHJldHVybiAkJHJlc3VsdDtcbiAgICBcdH1cblxuICAgIFx0JCRzZWxmLiRzZXQgPSAkJHByb3BzID0+IHtcbiAgICBcdFx0aWYgKCd2YWx1ZScgaW4gJCRwcm9wcykgJCRpbnZhbGlkYXRlKCd2YWx1ZScsIHZhbHVlID0gJCRwcm9wcy52YWx1ZSk7XG4gICAgXHRcdGlmICgnc3RlcCcgaW4gJCRwcm9wcykgJCRpbnZhbGlkYXRlKCdzdGVwJywgc3RlcCA9ICQkcHJvcHMuc3RlcCk7XG4gICAgXHRcdGlmICgnJCRzY29wZScgaW4gJCRwcm9wcykgJCRpbnZhbGlkYXRlKCckJHNjb3BlJywgJCRzY29wZSA9ICQkcHJvcHMuJCRzY29wZSk7XG4gICAgXHR9O1xuXG4gICAgXHRyZXR1cm4ge1xuICAgIFx0XHR2YWx1ZSxcbiAgICBcdFx0c3RlcCxcbiAgICBcdFx0Y2xpY2tfaGFuZGxlcixcbiAgICBcdFx0Y2xpY2tfaGFuZGxlcl8xLFxuICAgIFx0XHQkJHNsb3RzLFxuICAgIFx0XHQkJHNjb3BlXG4gICAgXHR9O1xuICAgIH1cblxuICAgIGNsYXNzIENvdW50ZXIgZXh0ZW5kcyBTdmVsdGVDb21wb25lbnREZXYge1xuICAgIFx0Y29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIFx0XHRzdXBlcihvcHRpb25zKTtcbiAgICBcdFx0aW5pdCh0aGlzLCBvcHRpb25zLCBpbnN0YW5jZSwgY3JlYXRlX2ZyYWdtZW50LCBzYWZlX25vdF9lcXVhbCwgW1widmFsdWVcIiwgXCJzdGVwXCJdKTtcbiAgICBcdH1cblxuICAgIFx0Z2V0IHZhbHVlKCkge1xuICAgIFx0XHR0aHJvdyBuZXcgRXJyb3IoXCI8Q291bnRlcj46IFByb3BzIGNhbm5vdCBiZSByZWFkIGRpcmVjdGx5IGZyb20gdGhlIGNvbXBvbmVudCBpbnN0YW5jZSB1bmxlc3MgY29tcGlsaW5nIHdpdGggJ2FjY2Vzc29yczogdHJ1ZScgb3IgJzxzdmVsdGU6b3B0aW9ucyBhY2Nlc3NvcnMvPidcIik7XG4gICAgXHR9XG5cbiAgICBcdHNldCB2YWx1ZSh2YWx1ZSkge1xuICAgIFx0XHR0aHJvdyBuZXcgRXJyb3IoXCI8Q291bnRlcj46IFByb3BzIGNhbm5vdCBiZSBzZXQgZGlyZWN0bHkgb24gdGhlIGNvbXBvbmVudCBpbnN0YW5jZSB1bmxlc3MgY29tcGlsaW5nIHdpdGggJ2FjY2Vzc29yczogdHJ1ZScgb3IgJzxzdmVsdGU6b3B0aW9ucyBhY2Nlc3NvcnMvPidcIik7XG4gICAgXHR9XG5cbiAgICBcdGdldCBzdGVwKCkge1xuICAgIFx0XHR0aHJvdyBuZXcgRXJyb3IoXCI8Q291bnRlcj46IFByb3BzIGNhbm5vdCBiZSByZWFkIGRpcmVjdGx5IGZyb20gdGhlIGNvbXBvbmVudCBpbnN0YW5jZSB1bmxlc3MgY29tcGlsaW5nIHdpdGggJ2FjY2Vzc29yczogdHJ1ZScgb3IgJzxzdmVsdGU6b3B0aW9ucyBhY2Nlc3NvcnMvPidcIik7XG4gICAgXHR9XG5cbiAgICBcdHNldCBzdGVwKHZhbHVlKSB7XG4gICAgXHRcdHRocm93IG5ldyBFcnJvcihcIjxDb3VudGVyPjogUHJvcHMgY2Fubm90IGJlIHNldCBkaXJlY3RseSBvbiB0aGUgY29tcG9uZW50IGluc3RhbmNlIHVubGVzcyBjb21waWxpbmcgd2l0aCAnYWNjZXNzb3JzOiB0cnVlJyBvciAnPHN2ZWx0ZTpvcHRpb25zIGFjY2Vzc29ycy8+J1wiKTtcbiAgICBcdH1cbiAgICB9XG5cbiAgICAvKiBzcmMvQXBwLnN2ZWx0ZSBnZW5lcmF0ZWQgYnkgU3ZlbHRlIHYzLjQuNCAqL1xuXG4gICAgY29uc3QgZmlsZSQxID0gXCJzcmMvQXBwLnN2ZWx0ZVwiO1xuXG4gICAgLy8gKDU6MikgPENvdW50ZXIgdmFsdWU9ezF9PlxuICAgIGZ1bmN0aW9uIGNyZWF0ZV9kZWZhdWx0X3Nsb3RfMShjdHgpIHtcbiAgICBcdHZhciB0O1xuXG4gICAgXHRyZXR1cm4ge1xuICAgIFx0XHRjOiBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgXHRcdFx0dCA9IHRleHQoXCJDb3VudGVyIDFcIik7XG4gICAgXHRcdH0sXG5cbiAgICBcdFx0bTogZnVuY3Rpb24gbW91bnQodGFyZ2V0LCBhbmNob3IpIHtcbiAgICBcdFx0XHRpbnNlcnQodGFyZ2V0LCB0LCBhbmNob3IpO1xuICAgIFx0XHR9LFxuXG4gICAgXHRcdGQ6IGZ1bmN0aW9uIGRlc3Ryb3koZGV0YWNoaW5nKSB7XG4gICAgXHRcdFx0aWYgKGRldGFjaGluZykge1xuICAgIFx0XHRcdFx0ZGV0YWNoKHQpO1xuICAgIFx0XHRcdH1cbiAgICBcdFx0fVxuICAgIFx0fTtcbiAgICB9XG5cbiAgICAvLyAoNjoyKSA8Q291bnRlciB2YWx1ZT17JGNvdW50fSBzdGVwPXszfT5cbiAgICBmdW5jdGlvbiBjcmVhdGVfZGVmYXVsdF9zbG90KGN0eCkge1xuICAgIFx0dmFyIHQ7XG5cbiAgICBcdHJldHVybiB7XG4gICAgXHRcdGM6IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICBcdFx0XHR0ID0gdGV4dChcIkNvdW50ZXIgMlwiKTtcbiAgICBcdFx0fSxcblxuICAgIFx0XHRtOiBmdW5jdGlvbiBtb3VudCh0YXJnZXQsIGFuY2hvcikge1xuICAgIFx0XHRcdGluc2VydCh0YXJnZXQsIHQsIGFuY2hvcik7XG4gICAgXHRcdH0sXG5cbiAgICBcdFx0ZDogZnVuY3Rpb24gZGVzdHJveShkZXRhY2hpbmcpIHtcbiAgICBcdFx0XHRpZiAoZGV0YWNoaW5nKSB7XG4gICAgXHRcdFx0XHRkZXRhY2godCk7XG4gICAgXHRcdFx0fVxuICAgIFx0XHR9XG4gICAgXHR9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZV9mcmFnbWVudCQxKGN0eCkge1xuICAgIFx0dmFyIGRpdiwgaDEsIHQwLCB0MSwgdDIsIHQzLCBwLCB0NCwgdDUsIGN1cnJlbnQ7XG5cbiAgICBcdHZhciBjb3VudGVyMCA9IG5ldyBDb3VudGVyKHsgJCRpbmxpbmU6IHRydWUgfSk7XG5cbiAgICBcdHZhciBjb3VudGVyMSA9IG5ldyBDb3VudGVyKHtcbiAgICBcdFx0cHJvcHM6IHtcbiAgICBcdFx0dmFsdWU6IDEsXG4gICAgXHRcdCQkc2xvdHM6IHsgZGVmYXVsdDogW2NyZWF0ZV9kZWZhdWx0X3Nsb3RfMV0gfSxcbiAgICBcdFx0JCRzY29wZTogeyBjdHggfVxuICAgIFx0fSxcbiAgICBcdFx0JCRpbmxpbmU6IHRydWVcbiAgICBcdH0pO1xuXG4gICAgXHR2YXIgY291bnRlcjIgPSBuZXcgQ291bnRlcih7XG4gICAgXHRcdHByb3BzOiB7XG4gICAgXHRcdHZhbHVlOiBjdHguJGNvdW50LFxuICAgIFx0XHRzdGVwOiAzLFxuICAgIFx0XHQkJHNsb3RzOiB7IGRlZmF1bHQ6IFtjcmVhdGVfZGVmYXVsdF9zbG90XSB9LFxuICAgIFx0XHQkJHNjb3BlOiB7IGN0eCB9XG4gICAgXHR9LFxuICAgIFx0XHQkJGlubGluZTogdHJ1ZVxuICAgIFx0fSk7XG5cbiAgICBcdHJldHVybiB7XG4gICAgXHRcdGM6IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICBcdFx0XHRkaXYgPSBlbGVtZW50KFwiZGl2XCIpO1xuICAgIFx0XHRcdGgxID0gZWxlbWVudChcImgxXCIpO1xuICAgIFx0XHRcdHQwID0gdGV4dChcIkhlbGxvIFwiKTtcbiAgICBcdFx0XHR0MSA9IHRleHQoY3R4Lm5hbWUpO1xuICAgIFx0XHRcdHQyID0gdGV4dChcIiFcIik7XG4gICAgXHRcdFx0dDMgPSBzcGFjZSgpO1xuICAgIFx0XHRcdHAgPSBlbGVtZW50KFwicFwiKTtcbiAgICBcdFx0XHRjb3VudGVyMC4kJC5mcmFnbWVudC5jKCk7XG4gICAgXHRcdFx0dDQgPSBzcGFjZSgpO1xuICAgIFx0XHRcdGNvdW50ZXIxLiQkLmZyYWdtZW50LmMoKTtcbiAgICBcdFx0XHR0NSA9IHNwYWNlKCk7XG4gICAgXHRcdFx0Y291bnRlcjIuJCQuZnJhZ21lbnQuYygpO1xuICAgIFx0XHRcdGgxLmNsYXNzTmFtZSA9IFwic3ZlbHRlLTF1Y2J6MzZcIjtcbiAgICBcdFx0XHRhZGRfbG9jYXRpb24oaDEsIGZpbGUkMSwgMSwgMCwgNik7XG4gICAgXHRcdFx0YWRkX2xvY2F0aW9uKHAsIGZpbGUkMSwgMiwgMCwgMjkpO1xuICAgIFx0XHRcdGFkZF9sb2NhdGlvbihkaXYsIGZpbGUkMSwgMCwgMCwgMCk7XG4gICAgXHRcdH0sXG5cbiAgICBcdFx0bDogZnVuY3Rpb24gY2xhaW0obm9kZXMpIHtcbiAgICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJvcHRpb25zLmh5ZHJhdGUgb25seSB3b3JrcyBpZiB0aGUgY29tcG9uZW50IHdhcyBjb21waWxlZCB3aXRoIHRoZSBgaHlkcmF0YWJsZTogdHJ1ZWAgb3B0aW9uXCIpO1xuICAgIFx0XHR9LFxuXG4gICAgXHRcdG06IGZ1bmN0aW9uIG1vdW50KHRhcmdldCwgYW5jaG9yKSB7XG4gICAgXHRcdFx0aW5zZXJ0KHRhcmdldCwgZGl2LCBhbmNob3IpO1xuICAgIFx0XHRcdGFwcGVuZChkaXYsIGgxKTtcbiAgICBcdFx0XHRhcHBlbmQoaDEsIHQwKTtcbiAgICBcdFx0XHRhcHBlbmQoaDEsIHQxKTtcbiAgICBcdFx0XHRhcHBlbmQoaDEsIHQyKTtcbiAgICBcdFx0XHRhcHBlbmQoZGl2LCB0Myk7XG4gICAgXHRcdFx0YXBwZW5kKGRpdiwgcCk7XG4gICAgXHRcdFx0bW91bnRfY29tcG9uZW50KGNvdW50ZXIwLCBwLCBudWxsKTtcbiAgICBcdFx0XHRhcHBlbmQocCwgdDQpO1xuICAgIFx0XHRcdG1vdW50X2NvbXBvbmVudChjb3VudGVyMSwgcCwgbnVsbCk7XG4gICAgXHRcdFx0YXBwZW5kKHAsIHQ1KTtcbiAgICBcdFx0XHRtb3VudF9jb21wb25lbnQoY291bnRlcjIsIHAsIG51bGwpO1xuICAgIFx0XHRcdGN1cnJlbnQgPSB0cnVlO1xuICAgIFx0XHR9LFxuXG4gICAgXHRcdHA6IGZ1bmN0aW9uIHVwZGF0ZShjaGFuZ2VkLCBjdHgpIHtcbiAgICBcdFx0XHRpZiAoIWN1cnJlbnQgfHwgY2hhbmdlZC5uYW1lKSB7XG4gICAgXHRcdFx0XHRzZXRfZGF0YSh0MSwgY3R4Lm5hbWUpO1xuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHZhciBjb3VudGVyMV9jaGFuZ2VzID0ge307XG4gICAgXHRcdFx0aWYgKGNoYW5nZWQuJCRzY29wZSkgY291bnRlcjFfY2hhbmdlcy4kJHNjb3BlID0geyBjaGFuZ2VkLCBjdHggfTtcbiAgICBcdFx0XHRjb3VudGVyMS4kc2V0KGNvdW50ZXIxX2NoYW5nZXMpO1xuXG4gICAgXHRcdFx0dmFyIGNvdW50ZXIyX2NoYW5nZXMgPSB7fTtcbiAgICBcdFx0XHRpZiAoY2hhbmdlZC4kY291bnQpIGNvdW50ZXIyX2NoYW5nZXMudmFsdWUgPSBjdHguJGNvdW50O1xuICAgIFx0XHRcdGlmIChjaGFuZ2VkLiQkc2NvcGUpIGNvdW50ZXIyX2NoYW5nZXMuJCRzY29wZSA9IHsgY2hhbmdlZCwgY3R4IH07XG4gICAgXHRcdFx0Y291bnRlcjIuJHNldChjb3VudGVyMl9jaGFuZ2VzKTtcbiAgICBcdFx0fSxcblxuICAgIFx0XHRpOiBmdW5jdGlvbiBpbnRybyhsb2NhbCkge1xuICAgIFx0XHRcdGlmIChjdXJyZW50KSByZXR1cm47XG4gICAgXHRcdFx0Y291bnRlcjAuJCQuZnJhZ21lbnQuaShsb2NhbCk7XG5cbiAgICBcdFx0XHRjb3VudGVyMS4kJC5mcmFnbWVudC5pKGxvY2FsKTtcblxuICAgIFx0XHRcdGNvdW50ZXIyLiQkLmZyYWdtZW50LmkobG9jYWwpO1xuXG4gICAgXHRcdFx0Y3VycmVudCA9IHRydWU7XG4gICAgXHRcdH0sXG5cbiAgICBcdFx0bzogZnVuY3Rpb24gb3V0cm8obG9jYWwpIHtcbiAgICBcdFx0XHRjb3VudGVyMC4kJC5mcmFnbWVudC5vKGxvY2FsKTtcbiAgICBcdFx0XHRjb3VudGVyMS4kJC5mcmFnbWVudC5vKGxvY2FsKTtcbiAgICBcdFx0XHRjb3VudGVyMi4kJC5mcmFnbWVudC5vKGxvY2FsKTtcbiAgICBcdFx0XHRjdXJyZW50ID0gZmFsc2U7XG4gICAgXHRcdH0sXG5cbiAgICBcdFx0ZDogZnVuY3Rpb24gZGVzdHJveShkZXRhY2hpbmcpIHtcbiAgICBcdFx0XHRpZiAoZGV0YWNoaW5nKSB7XG4gICAgXHRcdFx0XHRkZXRhY2goZGl2KTtcbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRjb3VudGVyMC4kZGVzdHJveSgpO1xuXG4gICAgXHRcdFx0Y291bnRlcjEuJGRlc3Ryb3koKTtcblxuICAgIFx0XHRcdGNvdW50ZXIyLiRkZXN0cm95KCk7XG4gICAgXHRcdH1cbiAgICBcdH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFuY2UkMSgkJHNlbGYsICQkcHJvcHMsICQkaW52YWxpZGF0ZSkge1xuICAgIFx0bGV0ICRjb3VudDtcblxuICAgIFx0XG4gICAgY29uc3QgY291bnQgPSB3cml0YWJsZSgxMDApOyB2YWxpZGF0ZV9zdG9yZShjb3VudCwgJ2NvdW50Jyk7IHN1YnNjcmliZSgkJHNlbGYsIGNvdW50LCAkJHZhbHVlID0+IHsgJGNvdW50ID0gJCR2YWx1ZTsgJCRpbnZhbGlkYXRlKCckY291bnQnLCAkY291bnQpOyB9KTtcbiAgICBsZXQgeyBuYW1lIH0gPSAkJHByb3BzO1xuICAgIG9uTW91bnQoKCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkFwcCBtb3VudGVkXCIpO1xuICAgIH0pO1xuXG4gICAgXHRjb25zdCB3cml0YWJsZV9wcm9wcyA9IFsnbmFtZSddO1xuICAgIFx0T2JqZWN0LmtleXMoJCRwcm9wcykuZm9yRWFjaChrZXkgPT4ge1xuICAgIFx0XHRpZiAoIXdyaXRhYmxlX3Byb3BzLmluY2x1ZGVzKGtleSkgJiYgIWtleS5zdGFydHNXaXRoKCckJCcpKSBjb25zb2xlLndhcm4oYDxBcHA+IHdhcyBjcmVhdGVkIHdpdGggdW5rbm93biBwcm9wICcke2tleX0nYCk7XG4gICAgXHR9KTtcblxuICAgIFx0JCRzZWxmLiRzZXQgPSAkJHByb3BzID0+IHtcbiAgICBcdFx0aWYgKCduYW1lJyBpbiAkJHByb3BzKSAkJGludmFsaWRhdGUoJ25hbWUnLCBuYW1lID0gJCRwcm9wcy5uYW1lKTtcbiAgICBcdH07XG5cbiAgICBcdHJldHVybiB7IGNvdW50LCBuYW1lLCAkY291bnQgfTtcbiAgICB9XG5cbiAgICBjbGFzcyBBcHAgZXh0ZW5kcyBTdmVsdGVDb21wb25lbnREZXYge1xuICAgIFx0Y29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIFx0XHRzdXBlcihvcHRpb25zKTtcbiAgICBcdFx0aW5pdCh0aGlzLCBvcHRpb25zLCBpbnN0YW5jZSQxLCBjcmVhdGVfZnJhZ21lbnQkMSwgc2FmZV9ub3RfZXF1YWwsIFtcIm5hbWVcIl0pO1xuXG4gICAgXHRcdGNvbnN0IHsgY3R4IH0gPSB0aGlzLiQkO1xuICAgIFx0XHRjb25zdCBwcm9wcyA9IG9wdGlvbnMucHJvcHMgfHwge307XG4gICAgXHRcdGlmIChjdHgubmFtZSA9PT0gdW5kZWZpbmVkICYmICEoJ25hbWUnIGluIHByb3BzKSkge1xuICAgIFx0XHRcdGNvbnNvbGUud2FybihcIjxBcHA+IHdhcyBjcmVhdGVkIHdpdGhvdXQgZXhwZWN0ZWQgcHJvcCAnbmFtZSdcIik7XG4gICAgXHRcdH1cbiAgICBcdH1cblxuICAgIFx0Z2V0IG5hbWUoKSB7XG4gICAgXHRcdHRocm93IG5ldyBFcnJvcihcIjxBcHA+OiBQcm9wcyBjYW5ub3QgYmUgcmVhZCBkaXJlY3RseSBmcm9tIHRoZSBjb21wb25lbnQgaW5zdGFuY2UgdW5sZXNzIGNvbXBpbGluZyB3aXRoICdhY2Nlc3NvcnM6IHRydWUnIG9yICc8c3ZlbHRlOm9wdGlvbnMgYWNjZXNzb3JzLz4nXCIpO1xuICAgIFx0fVxuXG4gICAgXHRzZXQgbmFtZSh2YWx1ZSkge1xuICAgIFx0XHR0aHJvdyBuZXcgRXJyb3IoXCI8QXBwPjogUHJvcHMgY2Fubm90IGJlIHNldCBkaXJlY3RseSBvbiB0aGUgY29tcG9uZW50IGluc3RhbmNlIHVubGVzcyBjb21waWxpbmcgd2l0aCAnYWNjZXNzb3JzOiB0cnVlJyBvciAnPHN2ZWx0ZTpvcHRpb25zIGFjY2Vzc29ycy8+J1wiKTtcbiAgICBcdH1cbiAgICB9XG5cbiAgICBjb25zdCBhcHAgPSBuZXcgQXBwKHtcclxuICAgICAgICB0YXJnZXQ6IGRvY3VtZW50LmJvZHksXHJcbiAgICAgICAgcHJvcHM6IHtcclxuICAgICAgICAgICAgbmFtZTogXCJ3b3JsZFwiXHJcbiAgICAgICAgfVxyXG4gICAgfSk7XG5cbiAgICByZXR1cm4gYXBwO1xuXG59KCkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVuZGxlLmpzLm1hcFxuIl0sInNvdXJjZVJvb3QiOiIifQ==</script><script type="text/javascript">/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./public/bundle.css":
/*!***************************!*\
  !*** ./public/bundle.css ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./public/global.css":
/*!***************************!*\
  !*** ./public/global.css ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 0:
/*!*****************************************************!*\
  !*** multi ./public/bundle.css ./public/global.css ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./public/bundle.css */"./public/bundle.css");
module.exports = __webpack_require__(/*! ./public/global.css */"./public/global.css");


/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2J1bmRsZS5jc3M/MmYxMSIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvZ2xvYmFsLmNzcz85NTk5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7UUFBQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTs7O1FBR0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDBDQUEwQyxnQ0FBZ0M7UUFDMUU7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSx3REFBd0Qsa0JBQWtCO1FBQzFFO1FBQ0EsaURBQWlELGNBQWM7UUFDL0Q7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLHlDQUF5QyxpQ0FBaUM7UUFDMUUsZ0hBQWdILG1CQUFtQixFQUFFO1FBQ3JJO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMkJBQTJCLDBCQUEwQixFQUFFO1FBQ3ZELGlDQUFpQyxlQUFlO1FBQ2hEO1FBQ0E7UUFDQTs7UUFFQTtRQUNBLHNEQUFzRCwrREFBK0Q7O1FBRXJIO1FBQ0E7OztRQUdBO1FBQ0E7Ozs7Ozs7Ozs7OztBQ2xGQSx1Qzs7Ozs7Ozs7Ozs7QUNBQSx1QyIsImZpbGUiOiJzdHlsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAwKTtcbiIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpbiIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpbiJdLCJzb3VyY2VSb290IjoiIn0=</script>